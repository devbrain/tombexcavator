Titus the Fox / Moktar SQZ file format by Jesses (smacdrek at hotmail dot com)
Visit http://ttf.mine.nu for more TTF/Moktar stuff

This file describes the format of SQZ files, and how to decompress them. One
of two compression algorithms is used: either LZW or Huffman. A byte at offset
1 determines which one of them is actually in use.



File format:
Offset	Size	What
0	1	bits 0..3 = high nibble of uncompressed size, bits 4..7 unused
1	1	10h if LZW is used, something else (i.e. 0) if Huffman is used
2	2	low word of uncompressed size

If LZW is used:
Offset	Size	What
4	rest	LZW bitstream

If Huffman is used:
Offset	Size	What
4	2	HTS: Huffman tree size in bytes
6	HTS	HT: Huffman tree as array of words
6+HTS	rest	Huffman bitstream



How to decode LZW bitstream:

The bitstream consists of 'nbit'-bit words, with 'nbit' varying (initially 9).
The first word in the stream and the first word after a CLEAR_CODE is always
< 256; neither of these words should cause an addition to the dictionary.
The last word in the stream is END_CODE; the number of (unused) bits following
it is at least 1 and at most 8.

Regarding bit-order: consider the first three bytes of a file, and label the
bits like this:
  76543210 FEDCBA98 NMLKJIHG
then, the first two 9-bit words are:
  76543210F EDCBA98NM

Constants:
	CLEAR_CODE	= 100h
	END_CODE	= 101h
	FIRST		= 102h
	MAX_TABLE	= 4096

Pseudocode:
	nbit := 9
	dict := []
	addtodict := false
	while (k := next nbit-sized word) {
		if (k == CLEAR_CODE) {
			nbit := 9
			dict := []
			addtodict := false
		} else if (k != END_CODE) {
			if (k > 255 && k < FIRST + dict.length) {
				entry := dict[k - FIRST]
			} else if (k > 255 && k >= FIRST + dict.length) {
				entry := w ++ w[0]
			} else {
				entry := k
			}
			output entry
			if (addtodict && FIRST + dict.length < MAX_TABLE) {
				add w ++ entry[0] to dict
			}
			w := entry
			addtodict := true
		}
		if (FIRST + dict.length == 2**nbit && nbit < 12) {
			nbit++
		}
	}



How to decode Huffman bitstream:

The binary Huffman tree HT is stored as array of words, where each word
represents a node; each node is either an internal node or a leaf node. The
value stored in the array for a node has two parts: bit 15 is set if it is a
leaf node, bits 0..14 contain the node's value. For leaf nodes this value is a
codeword, for internal nodes it is 2*(index of left child). The right child of
an internal node is stored immediately after its left child.
HT is traversed using input bits to determine the path to a leaf, where an
input of 0 means take the left child and 1 means take the right child.

Pseudocode for reading codewords:
	node := 0
	while (b := next bit) {
		if (b) {
			node++
		}
		if (HT[node] is an internal node) {
			node := HT[node] / 2
		} else {
			H := HT[node] bits 8..14
			L := HT[node] bits 0..7
			process codeword HL
			node := 0
		}
	}

Codewords HL are processed in the following way:

Codeword	What to do
H==0		output 'L'; last := L
H!=0 && L==0	read next codeword HL; output HL times 'last'
H!=0 && L==1	read next codeword xH; read next codeword xL; output HL times 'last'
H!=0 && L>=2	output L times 'last'

Pseudocode for processing a codeword HL; initially, state==0:
	if (state == 0) {
		if (H == 0) {
			output L
			last := L
		} else if (L == 0) {
			state := 1
		} else if (L == 1) {
			state := 2
		} else {
			output L times 'last'
		}
	} else if (state == 1) {
		output HL times 'last'
		state := 0
	} else if (state == 2) {
		count := 256*L
		state := 3
	} else if (state == 3) {
		count += L
		output count times 'last'
		state := 0
	}
